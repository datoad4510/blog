<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Nth multiple of primes We are given a sorted array of prime numbers $P$, and an integer $n$. We want to find the nth largest number whose prime factors are in $P$."><title>ðŸª´ Quartz 3.3</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://datoad4510.github.io/blog//icon.png><link href=https://datoad4510.github.io/blog/styles.7153093e4d1bbb584a28469cadfa3f88.min.css rel=stylesheet><link href=https://datoad4510.github.io/blog/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://datoad4510.github.io/blog/js/darkmode.eff346993566569ec4f9fc9db9a07116.min.js></script>
<script src=https://datoad4510.github.io/blog/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://datoad4510.github.io/blog/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://datoad4510.github.io/blog/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://datoad4510.github.io/blog/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://datoad4510.github.io/blog/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://datoad4510.github.io/blog/",fetchData=Promise.all([fetch("https://datoad4510.github.io/blog/indices/linkIndex.88953b393cd59577766732686c3a45d1.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://datoad4510.github.io/blog/indices/contentIndex.649ffc3e8af0a45a46071799636a562c.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://datoad4510.github.io/blog",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://datoad4510.github.io/blog",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'â€™':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/datoad4510.github.io\/blog\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://datoad4510.github.io/blog/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://datoad4510.github.io/blog/>ðŸª´ Quartz 3.3</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Oct 13, 2022
<a href=https://github.com/jackyzha0/quartz/tree/hugo/content/notes/Algorithms/Nth%20multiple%20of%20primes/Nth%20multiple%20of%20primes.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><ol><li><a href=#nth-multiple-of-primes>Nth multiple of primes</a></li><li><a href=#solution>Solution</a></li></ol></li></ol></nav></details></aside><a href=#nth-multiple-of-primes><h3 id=nth-multiple-of-primes><span class=hanchor arialabel=Anchor># </span>Nth multiple of primes</h3></a><p>We are given a sorted array of prime numbers $P$, and an integer $n$. We want to find the nth largest number whose prime factors are in $P$. In other words, we have the following sets:</p><p>$$\begin{array}{l}
S={; p_{1}^{k_1}p_{2}^{k_2}&mldr;p_{m}^{k_m} ;| ;k_1,;k_2,;&mldr;,;k_m \ge 0 ; \text{and} ; ;p_1,;p_2,;&mldr;,;p_m \in P ; } \[4ex]
P={ ; p_1,;p_2,;&mldr;,;p_m ; }, ; \text{where every element of P is prime. $m \ge 1$.}
\end{array}$$</p><p>Now, if we order the elements of $S$ from the smallest (which would be 1, $k_1=;k_2=;&mldr;=;k_n=0$) to the largest, we want the nth number in this ordering.</p><p>**Example:</p><p>Let&rsquo;s say $P=[2,3,5]$ and $n=5$. Then the numbers in increasing order are:
$$1 == 2^03^05^0,2 == 2^13^05^0,3 == 2^03^15^0, 4 == 2^23^05^0, 5 == 2^03^05^1$$
We return the fifth number, is 5.</p><a href=#solution><h3 id=solution><span class=hanchor arialabel=Anchor># </span>Solution</h3></a><p>Let $A$ be an array consisting of $n$ elements, where $A[i]$ is the i-th largest element of $S$. Let $P$ be the array containing the prime number factors in sorted order.</p><p>It&rsquo;s easy to notice that there is a kind of recursive pattern among these numbers. For example, $2^13^15^0==2*2^03^15^0$. So, by moving one of the primes out of the number, we are still left with a number whose prime factors are 2,3 and 5. Additionally, this new number is strictly smaller than the initial one. This means that the new number is an element of $A$ and its index is less than the index of the initial number.</p><p>This gives us hope that there might be a recursive formula for finding $A[n]$ using the values $A[n]/2,A[n]/3$ and $A[n]/5$. The problem is, we still have no idea where exactly in $A$ these three numbers are. We need recursive calls that decrease the index, which we don&rsquo;t have.</p><p>So, what else do we know? Let&rsquo;s get back to the idea that $A[n]$ is equal to $A[i]$ times 2,3 or 5, where $1 \le i \lt n$. We can go over the whole array and multiply each of the elements by 2,3 and 5. We basically generate every candidate answer. $A[n]$ must be one of these by the method of exhaustion. But which one? Well, if any of the candidates are already in $A$, we can skip them, because $A[n]$ is strictly greater than all the elements before it. Every candidate that&rsquo;s left is an element of $S$, and all of them come after $A[n-1]$ in the ordering. Because we want the immediate successor of $A[n-1]$, we take the minimum of what&rsquo;s left of the candidates. This will be the answer!</p><p>Calculating all the candidates will take $O(n*|P|)$ time. Finding the minimum will have the same time complexity. Since we are building the $A$ array incrementaly, we will need to do this $n$ times. So, the final time complexity will be $O(n^2*|P|)$.</p><p>Notice that we are doing extra work: every time we calculate the canidate answers, we just throw them out instead of reusing them in the future. There also might be a way to quickly skip all the candidates that are already in $A$. This gives us motivation to try and optimize the solution.</p><p>We can keep all the valid candidates in an ordered set. An ordered set automatically filters duplicates. At every step of the algorithm, we calculate the next element of the array by taking the minimum of the set. We then erase this element from the set, because it will never be a valid candidate in the future. We then look at this element times 2,3 and 5, and add only the valid ones out of these three to the set (Every other element times 2,3,5 was already considered and appropriately filtered when it was added to the array!). How do we know which of these three are valid? We also keep a hashset of all the previous elements of the array, and so we just check which of them are in the hashset. After calculating the next element in the array, we also add it to the hashset.</p><p>The time complexity all the set operations during each step of the algorithm will be $O(|P|log(n))$. There will be $n$ steps, so the total time complexity will be $O(|P|n*log(n))$. The space complexity will be $O(n)$.</p><p>Surprisingly, there is also a $O(n*log(|P|))$ time complexity solution. This solution hinges on the observation that every time we are calculating the next element of the array, we know that there are exactly $|P|$ possible candidates. At each step of the algorithm, $A[i]$ is the minimum of these candidates. After finding it, we replace it in the candidate list with another candidate. We keep the candidates in a heap, which explains the logarithm in the time complexity.</p><p>So, which candidates are these? Well, we know that $A[1] == 1$. Based on this, the possible candidates for $A[2]$ are 2,3 and 5. We take the minimum of these three, which is 2. So, two is not going to be in the candidate space for $A[3]$. So now we have ${\color{red}2<em>2,}{\color{cyan}3</em>1,3<em>2,}{\color{green}5</em>1,5<em>2}$ as the candidates. Notice how we grouped them. Now, we know that $3</em>2$ and $5<em>2$ cannot be $A[3]$, because we have smaller values in the candidate space, namely $3</em>1$ and $5*1$.</p><p>The minimum of these is 3, we remove it from the list and add more candidates:
$${\color{red}2<em>2,2</em>3,}{\color{cyan}3<em>2,3</em>3,}{\color{green}5<em>1,5</em>2,5*3}$$
Each of the goups corresponds to new candidates generated by previous elements. The first group corresponds to an element times 2, the second one times 3 and so on. What can we say about these groups? We know that at every step of the algorithm, all of the candidates in these groups were generated by older elements of the array. These older elements were strictly less than the one we are currently calculating! So, when we add the current element times 2 to the first group, for example, it will be greater than the candidates in the same group before it (if $x \lt y$, then $2x \lt 2y$). Same goes for all the other primes. This means that, the groups will be in sorted order at every point in time!</p><p>Because the groups are sorted, we know that the smallest candidate must be one of the starting values of the three groups ($|P|$ groups in general). So, we just keep these values in a heap, as we already stated above. When we are calculating a candidate, we remove one item from the lists (minimum of the groups) and then add $|P|$ candidates. All in all, at every step, we add $|P|-1=O(|P|)$ number of elements. Since this will be done $n$ times, the space complexity of this algorithm will be $O(|P|*n)$.</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://datoad4510.github.io/blog/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Jacky Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2022</p><ul><li><a href=https://datoad4510.github.io/blog/>Home</a></li><li><a href=https://twitter.com/_jzhao>Twitter</a></li><li><a href=https://github.com/jackyzha0>Github</a></li></ul></footer></div></div></body></html>