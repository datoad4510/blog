<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Burtsing balloons You are givenÂ nÂ balloons, indexed fromÂ 0Â toÂ n - 1. Each balloon is painted with a number on it represented by an arrayÂ nums."><title>ðŸª´ Quartz 3.3</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://datoad4510.github.io/test-blog//icon.png><link href=https://datoad4510.github.io/test-blog/styles.7153093e4d1bbb584a28469cadfa3f88.min.css rel=stylesheet><link href=https://datoad4510.github.io/test-blog/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://datoad4510.github.io/test-blog/js/darkmode.acade3b8ed18a339bcee82e811d8ee56.min.js></script>
<script src=https://datoad4510.github.io/test-blog/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://datoad4510.github.io/test-blog/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://datoad4510.github.io/test-blog/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://datoad4510.github.io/test-blog/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://datoad4510.github.io/test-blog/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://datoad4510.github.io/test-blog/",fetchData=Promise.all([fetch("https://datoad4510.github.io/test-blog/indices/linkIndex.88953b393cd59577766732686c3a45d1.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://datoad4510.github.io/test-blog/indices/contentIndex.d80c0aeb63888bc3732f3fdf3c694a53.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://datoad4510.github.io/test-blog",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://datoad4510.github.io/test-blog",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'â€™':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/datoad4510.github.io\/test-blog\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://datoad4510.github.io/test-blog/js/full-text-search.24827f874defbbc6d529926cbfcfb493.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://datoad4510.github.io/test-blog/>ðŸª´ Quartz 3.3</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Oct 13, 2022
<a href=https://github.com/jackyzha0/quartz/tree/hugo/content/notes/Algorithms/Bursting%20Balloons/Bursting%20balloons.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><ol><li><a href=#burtsing-balloons>Burtsing balloons</a></li><li><a href=#solution>Solution:</a></li></ol></li></ol></nav></details></aside><a href=#burtsing-balloons><h3 id=burtsing-balloons><span class=hanchor arialabel=Anchor># </span>Burtsing balloons</h3></a><p>You are givenÂ <code>n</code>Â balloons, indexed fromÂ <code>0</code>Â toÂ <code>n - 1</code>. Each balloon is painted with a number on it represented by an arrayÂ <code>nums</code>. You are asked to burst all the balloons.</p><p>If you burst theÂ <code>ith</code>Â balloon, you will getÂ <code>nums[i - 1] * nums[i] * nums[i + 1]</code>Â coins. IfÂ <code>i - 1</code>Â orÂ <code>i + 1</code>Â goes out of bounds of the array, then treat it as if there is a balloon with aÂ <code>1</code>Â painted on it.</p><p>ReturnÂ <em>the maximum coins you can collect by bursting the balloons wisely</em>.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> nums = [3,1,5,8]
<strong>Output:</strong> 167
<strong>Explanation:</strong>
nums = [3,1,5,8] &ndash;> [3,5,8] &ndash;> [3,8] &ndash;> [8] &ndash;> []
coins = 3<em>1</em>5 + 3<em>5</em>8 + 1<em>3</em>8 + 1<em>8</em>1 = 167</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> nums = [1,5]
<strong>Output:</strong> 10</p><p><strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><a href=#solution><h3 id=solution><span class=hanchor arialabel=Anchor># </span>Solution:</h3></a><p>Whenever a problem asks us to maximize something, there can be a few cases. One scenario is that the best solution is to just brute-force the problem. Make every possible choice for the first baloon to pop, then the second baloon, etc. and return the maximum of all possibilities. The amount of steps here would be at least $n!$.</p><p>Another scenario is that the problem exhibits some kind of greedy structure, wherein making locally optimal choices leads to a globally optimal solution. This is clearly not the case here if we just look at the array [100,1,100] :
$$(1<em>100</em>1)+(1<em>100</em>1)+(1<em>1</em>1)\lt(100<em>1</em>100)+(1<em>100</em>100)+(1<em>100</em>1)$$</p><p>Sometimes, we can optimize brute-force solutions by caching the solutions to its sub-problems. However, if you try to optimize the solution above, you will see that it&rsquo;s very hard to do so. The subproblems will be subsequences of the original array, because we don&rsquo;t know in what order the baloons will be popped when simulating the process. In fact, we will have to look at every possible ordering! For each subproblem, the value also depends on what previous baloons we popped, because the left and right boundaries will be different. We would need to query subproblem solutions by providing both the subsequences <strong>and</strong> their possible boundaries. We would have to hash the subsequences, which will be a pain. The number of subproblems would be in the order of the number of subsequences of the original array. This is the same as the number of subsets of a set of cardinality n, which is $2^n$. Clearly this solution will be hard to code and slow (but still faster than the brute force approach).</p><p>There is a better way to do this. Instead of thinking about the problem moving forward in time, we can think backwards. Let&rsquo;s say $nums[i]$ is the <strong>last</strong> balloon we pop. We know what the left and right boundaries will be when this pop happens, because all the other balloons will be gone, regardless of the order they were popped in! This helps us avoid caching all the possible boundaries and just focus on one. For the whole array, the boundaries will be 1 and 1, because they are out of bounds.
<img src=https://datoad4510.github.io/test-blog//notes/Algorithms/Bursting%20Balloons/full_arr.svg width=auto alt=full_arr></p><p>But since we don&rsquo;t know which balloon we should save for last, we need to try all of them. And for each of those cases, we need to try every possible way to pop the second-to-last balloon and etc. We will then take the maximum of all of these possibilities! Now the recursive structure of this solution is becoming clear, and we notice that we are doing repeated work.</p><p>We can cache the solutions to the subproblems (subarrays) by using the left and right indices of the subarrays as keys in a table. The value will be the solution for the given array.</p><p>Now let&rsquo;s look at a general subproblem. Let&rsquo;s say we want to know $maxCoins(nums[L,R])$. Let $i\in[L..R]$, again, be the last baloon popped in the subarray $[L..R]$.</p><p><img src=https://datoad4510.github.io/test-blog//notes/Algorithms/Bursting%20Balloons/subproblem.svg width=auto alt=subproblem></p><p>We see that the left and right boundaries of the left subarray will be $nums[L-1]$ and $nums[i]$ respectively. The left and right boundaries of the right subarray will be $nums[i]$ and $nums[R+1]$. And, of course, we finally pop $nums[i]$ and get $nums[L-1]*nums[i]*nums[R+1]$ amount of coins.</p><p>Again, the most important point of this process is that <strong>the boundaries do not change while we pop the baloons.</strong> Because of this, both of the subarrays can be sure what the boundaries are at all times without worrying about them changing.</p><p>So the final recursive formula becomes the sum of the coins made from the left subarray, the right subarray, and popping the i-th balloon. And so, we take the maximum of all possible values of $i$:</p><p>$$maxCoins(nums[L..R]) = Max_{i=L}^{i=R}(nums[L-1]*nums[i]*nums[R+1] + maxCoins(nums[L..i-1]) + maxCoins(nums[i+1..R]))$$</p><p>$$nums[i..j] == 0, i \gt j$$</p><p>Because we are keeping the boundaries constant while solving subproblems, going out of bounds does not scare us. By the way, the last equation we wrote is just to make the recursive formula more readable by taking care of edge cases.</p><p>We also have the following base case:
$$maxCoins(i,i) == nums[i-1]*nums[i]*nums[i+1]$$</p><p>The top-down memoized solution is now clear. The only difficulty would be to hash pairs of integers in C++ to use as keys in the hash-map. We can circumvent this by creating a bottom-up solution that doesn&rsquo;t use recursion, which reduces the memory overhead. In most cases, such iterative solutions are faster than memoized recursive programs. However, there are cases when we might fill the dynamic programming table in a non-optimal order that will take more operations than a recursive solution would, because a recursive algorithm, by definition, will only calculate those cells that it actually needs to solve the problem. We will talk about this in more detail at a later time.</p><p><img src=https://datoad4510.github.io/test-blog//notes/Algorithms/Bursting%20Balloons/dp-table.svg width=auto alt=dp-table></p><p>(The cells below the diagonal are filled with 0s).</p><p>We can see from the above picture that to calculate $dp[L][R]$, we need to sum up corresponding pairs (balls of same color) plus $nums[i-1]*nums[i]*nums[j+1]$ and take the maximum. That value will go into the &ldquo;white ball&rdquo;, which corresponds to $dp[L][R]$.</p><p>To get to the target, we need to know all the values of row 0 and column n-1. Those values themselves clearly require us to calculate all the values in the whole table. Because of this, we cannot skip any work. For this problem, the bottom-up solution does the exact same work as the top-down one, so the iterative algorithm should be better in every way.</p><p>At first we start with the red balls (the base cases). We can calculate the green cells straight away. After those, we start calculating the blue cells and etc. until we get to the target. Calculating the value of each cell takes $O(n)$ time, there are $O(n^2)$ number of cells, and so the time complexity of this solution is $O(n^3)$. The space taken up by the matrix will be $O(n^2)$. Coding this solution is trivial.</p><p>Another thing to think about is how we would make this solution faster by using multithreading. We could calculate the value of each cell on the diagonal at the same time, because all the values on the same diagonal are independent. This would reduce the time complexity of the algorithm to $O(n^2)$.</p><p>At first we might think that we can further optimize the solution by only storing one diagonal at a time, and changing up the values of this diagonal so that we can instantly calculate the values of the next one, but there is no obvious way to do this in this problem. I can&rsquo;t prove that we can&rsquo;t do it either, but it seems to me that it should be impossible from an information-theoretic point of view.</p><p>Now some further questions:</p><p>1.) Print the order in which we popped the balloons to get our optimal solution</p><p>2.) How many different ways can we pop the balloons? (permutations)</p><p>3.) Count how many ways we can get the maximum profit by popping the balloons in different order.</p><p>4.) Print the order of pops from the previous question</p><p>To help us solve some of these problems, notice that, when we popped the i-th balloon, we got two subarrays, one on the left and another on the right. Say we have a list of pop operations given to us that happened after the first pop: $L_1,L_2,R_1,L_3,R_2$. The L-pops correspond to pop operations in the left subarray and R-pops in the right. Notice that if we change the relative ordering among the left pops, we will get a different answer in the left subproblem! The order in which we pop the baloons matters. Same goes for the right pops.</p><p>However, keeping the relative order intact among the pops in each of the halves and changing when we do the left pops as compared to the right pops does not change the final answer, because operations in one half does not affect another! So the above sequence of pops is equivalent to, for example, $L_1,L_2,L_3,R_1,R_2$.</p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/test-blog// data-ctx="Bursting balloons" data-src=/ class=internal-link>Blog</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://datoad4510.github.io/test-blog/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Jacky Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2022</p><ul><li><a href=https://datoad4510.github.io/test-blog/>Home</a></li><li><a href=https://twitter.com/_jzhao>Twitter</a></li><li><a href=https://github.com/jackyzha0>Github</a></li></ul></footer></div></div></body></html>